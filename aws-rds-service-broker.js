/**
 * This has been enahnced from the original version created by Mark van Holsteijn, Xebia Nederland B.V.
 *
 * Cloud Foundry Service Broker complyies to version 2.8 of the interface specification
 * http://docs.cloudfoundry.org/services/api.html
 *
 * It implements the following methods:
 *
 * 1) The catalog of services and plans is stored in the config/aws-rds-service-broker.json. This will be changed to
 *    leverage plans that are defined through a set of Cloud Formation templates with future releases
 *
 * 2) Provision: The service broker will create a Amazon RDS database instance, the following are added as tags to
 *    the provisioned instance:
 *      --> Org ID - this uniquely identifies the organization in PCF that requested the instance
 *      --> Space ID - this uniquely identifies the space in PCF that requested the instance
 *      --> Service ID - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB
 *      --> Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                        Cloud Controller
 *      --> Plan ID - this uniquely identifies the attributes of the instance, e.g. physical resources, iiops, etc
 *
 * 3) Bind: search for the specified service instance with a matching tag and return the credentials.
 * 
 * 4) Deprovision: search for the specified service instance with matching tag and deletes it.
 *
 * The bind does not keep any registration. The service broker is stateless: all information is stored in AWS.
 *
 * The catalog of services and plans is stored in the config/aws-rds-service-broker.json.
 *
 * For more information, check the README.md
 */


'use strict';

/**
 * Declare All Dependencies
 */
var config = require('./config/aws-rds-service-broker');
//TODO: Replace with DB like Redis/MariaDB in order to support mutiple brokers
var instances = new Map();
//Load the Plans, i.e. Cloud Formations
var smallPlan = require('./config/plan1-mariadb_v1');
var mediumPlanNoHA = require('./config/plan2a-mariadb_v1');
var mediumPlanHA = require('./config/plan2b-mariadb_v1');
var largePlanNonHA = require('./config/plan3a-mariadb_v1');
var largePlanHA = require('./config/plan3b-mariadb_v1');
var scommon = require('./security-common');
var restify = require('restify');
var async = require('async');
var Handlebars = require('handlebars');

/* following configs are determined by environment variables */
config.credentials = {};

/**
 *   Cloud Controller will authenticate to Broker with the credentials that were generated/created when
 *   the broker was installed in the foundation
 */
config.credentials.authUser = (process.env.SERVICE_BROKER_USERNAME);
config.credentials.authPassword = (process.env.SERVICE_BROKER_PASSWORD);

/**
 * The broker will create new instances in the defined region, e.g. US-EAST-1 (Discover Default)
 * AWS will ensure that for availability purposes that instances along with replicas are spread across subnets
 * which are located on different availability zones. Only applicable to plans where HA is an option
 *
 */
config.aws = {};
config.aws.Region = (process.env.AWS_REGION);
config.aws.DBSubnetGroupName = (process.env.AWS_DBSUBNET_GROUP_NAME);
var aws = require('aws-sdk');
aws.config.region = config.aws.Region;
var rds = new aws.RDS();
var iam = new aws.IAM();
var cloudFormation = new aws.CloudFormation({apiVersion: '2010-05-15'});



var urlTemplates = {};

/**-------------------------------------------------------
 * Create and configure the node server - restify module
 --------------------------------------------------------*/

var server = restify.createServer({
    name: 'aws-rds-service-broker'
});

//Create a handler(function) to ensure that the broker enforces a specific api version (2.8 is latest)
server.use(apiVersionChecker({
    'major': 2,
    'minor': 4
}));

server.use(restify.authorizationParser());
server.use(authenticate(config.credentials));
server.use(restify.fullResponse());
server.use(restify.bodyParser());
server.pre(restify.pre.userAgentConnection());

//--------------------End Server Configuration---------------------
 
//TODO: This is for the test UI, will need to altered for marketplace usage
function compileTemplates() {
    var i, p, id, str, result = {};
    for (i = 0; i < config.catalog.services.length; i += 1) {
        for (p = 0; p < config.catalog.services[i].plans.length; p += 1) {
            id = config.catalog.services[i].plans[p].id;
            str = config.plans[id].urlTemplate;
            result[id] = Handlebars.compile(str);
        }
    }
    return result;
}

/**--------------------------------------------------------------------------
 * Map broker api /v2/catalog to a return of the catalog - this will return
 * the details for the plans configured in the json file
 ----------------------------------------------------------------------------*/
server.get('/v2/catalog', function(request, response, next) {
    //catalog loaded from json file on server startup
    response.send(config.catalog);
    next();
});

//--------------------------End /v2/catalog broker API------------------------
/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id>/last_operation
 *
 * This will support by client (e.g. cloud controller) to see the state of the last operation
 *
 * AWS provisioning will be asynchronous so binding will have to be a subsequent step
 *              1) Org ID - this uniquely identifies the organization in PCF that requested the instance
 *              2) Space ID - this uniquely identifies the space in PCF that requested the instance
 *              3) Service ID - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB
 *              4) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller and is part of url not json request params
 *              5) Plan ID - this uniquely identifies the attributes of the instance, e.g. physical resources, iiops,etc
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.put('/v2/service_instances/:instance_id/last_operation', function(request, response, next) {
    
});
/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id> to provisioning of new instance based on passed in parameters
 * AWS provisioning will be asynchronous so binding will have to be a subsequent step
 *              1) Org ID - this uniquely identifies the organization in PCF that requested the instance
 *              2) Space ID - this uniquely identifies the space in PCF that requested the instance
 *              3) Service ID - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB
 *              4) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller and is part of url not json request params
 *              5) Plan ID - this uniquely identifies the attributes of the instance, e.g. physical resources, iiops,etc
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.put('/v2/service_instances/:id', function(request, response, next) {
    var msg = validateProvisioningRequest(request);
    if(msg!=""){
        response.send(422,msg);
        next();
    }
    else {
        createRDSFromFormation(request, response, next, config.plans[request.params.plan_id]);
    }
});

//---------------------------------------End /v2/service_instances/:id  broker API--------------------------------------

/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id> to de-provisioning of existing instance
 *              1) Service ID - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB
 *              2) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller and is part of url not json request params
 *              3) Plan ID - this uniquely identifies the attributes of the instance, e.g. physical resources, iiops,etc
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 * TODO: Once vault is integrated will have to remove credentials associated with this instance
 ---------------------------------------------------------------------------------------------------------------------*/
server.del('/v2/service_instances/:id', function(req, response, next) {
    getAllDbInstances(new DbInstanceIdFilter(req.params.id), function(err, allMatchingInstances) {
        var instance, params;

        if (!err && allMatchingInstances && allMatchingInstances.length > 0) {
            instance = allMatchingInstances[0];
            params = {
                DBInstanceIdentifier: instance.DBInstanceIdentifier
            };

            if (instance.DBInstanceStatus !== "creating") {
                params.FinalDBSnapshotIdentifier = ('Final-snapshot-' + instance.DBInstanceIdentifier);
                params.SkipFinalSnapshot = false;
            } else {
                params.SkipFinalSnapshot = true;
            }

            rds.deleteDBInstance(params, function(err, rdsResponse) {
                if (!err) {
                    response.send({});
                } else {
                    response.send(500, {
                        'description': err
                    });
                    console.log(err);
                }
            });
        } else {
            if (!err) {
                response.send(410, {
                    'description': "instance no longer exists"
                });
            } else {
                response.send(500, {
                    'description': err
                });
                console.log(err);
            }
        }
        next();
    });
});

//---------------------------------------End /v2/service_instances/:id broker API---------------------------------------

/**---------------------------------------------------------------------------------------------------------------------
 * TODO:This is not part of the official broker API and can eventually be removed
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.get('/v2/service_instances', function(request, response, next) {
    getAllDbInstances(new DbInstanceNoFilter(), function(err, allDatabaseInstances) {
        if (!err) {
            async.map(allDatabaseInstances, function(instance, callback) {
                    var result = {};
                    result.id = getInstanceId(instance);
                    result.service_id = getServiceId(instance);
                    result.plan_id = getPlanId(instance);
                    result.organization_guid = getOrgId(instance);
                    result.space_guid = getSpaceId(instance);
                    result.db_instance_id = instance.DBInstanceIdentifier;
                    if (instance && instance.Endpoint) {
                        result.credentials = getCredentials(instance, result.plan_id);
                    }

                    callback(null, result);
                },
                function(err, result) {
                    if (err) {
                        response.send(500, {
                            'description': err
                        });
                    } else {
                        response.send(result);
                    }
                });
        } else {
            response.send(500, err);
        }
        next();
    });
});

//---------------------------------------end of /v2/service_instances API-----------------------------------------------

/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id> /service_bindings/<bind id> to bind application to existing
 * service. AWS provisioning will be asynchronous so binding will have to be a subsequent step
 *              1) Service ID (optional) - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB. BODY
 *              2) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller. URL
 *              3) Plan ID (optional) - this uniquely identifies the attributes of the instance,
 *                                      e.g. physical resources, iiops,etc. BODY
 *              4) App_GUID - this is the guid of the application that is being bound to the service. BODY
 *              5) Bind ID - this is an id that is generated by the Cloud Controller, it must be tracked such that an
 *                           unbind correctly deletes credentials associated with a given service. URL
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 *  TODO: Change credential management to vault, flow should be:
 *          1) Ensure instance id exists
 *          2) Check bind id and do the following:
 *              a) If bind id is non-unique, generate new set of credentials, i.e. rebind
 *              b) If bind id is unique, generate new set of credentials, i.e. bind
 *          3) Tag RDS instance with bind id
 *          4) Tag vault credentials with bind id
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.put('/v2/service_instances/:instance_id/service_bindings/:binding_id', function(req, response, next) {
    var reply = {};

    getAllDbInstances(new DbInstanceIdFilter(req.params.instance_id), function(err, allDatabaseInstances) {
        var i = 0,
            instance = null,
            tag = null;

        if (!err) {
            if (allDatabaseInstances && allDatabaseInstances.length > 0) {
                instance = allDatabaseInstances[0];
                if (instance && instance.Endpoint) {
                    //TODO: Credentials on a bind needs to be generated, stored in vault
                    reply.credentials = getCredentials(instance, getPlanId(instance));
                    response.send(reply);
                } else {
                    response.send(503, {
                        'description': "No endpoint set on the instance '" + instance.DBInstanceIdentifier + "'. The instance is in state '" + instance.DBInstanceStatus + "'. please retry a few minutes later"
                    });
                }
            } else {
                response.send(500, {
                    'description': 'database instance has been deleted.'
                });
            }
        } else {
            response.send(500, {
                'description': err
            });
        }
        next();
    });
});

//-----------------------end of /v2/service_instances/:instance_id/service_bindings/:binding_id------------------------- 

/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id> /service_bindings/<bind id> to unbind application from existing
 * service. AWS de-provisioning will be asynchronous but credential deletion from Vault will be synchronous
 *              1) Service ID (optional) - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB. URL
 *              2) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller. URL
 *              3) Plan ID (optional) - this uniquely identifies the attributes of the instance,
 *                                      e.g. physical resources, iiops,etc. URL
 *              4) Bind ID - this is an id that is generated by the Cloud Controller, it must be tracked such that an
 *                           unbind correctly deletes credentials associated with a given service. URL
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 *  TODO: Change credential management to vault, flow should be:
 *          1) Ensure instance id exists
 *          2) Check bind id and do the following:
 *              a) If bind id is non-unique, generate new set of credentials, i.e. rebind
 *              b) If bind id is unique, generate new set of credentials, i.e. bind
 *          3) Tag RDS instance with bind id
 *          4) Tag vault credentials with bind id
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.del('/v2/service_instances/:instance_id/service_bindings/:id', function(req, response, next) {
    response.send({});
    next();
});

//-------------------------------end /v2/service_instances/:instance_id/service_bindings/:id----------------------------

//Retrieve AWS Tag Value TODO: Delete?
function getTagValue(instance, key) {
    var i, tag;
    for (i = 0; i < instance.TagList.length; i += 1) {
        tag = instance.TagList[i];
        if (tag.Key === key) {
            return tag.Value;
        }
    }
    return undefined;
}

//Get ServiceID Tag Value TODO: Delete?
function getServiceId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-SERVICE-ID');
}

//Get PlanID Tag Value TODO: Delete?
function getPlanId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-PLAN-ID');
}

//Get OrgID Tag Value TODO: Delete?
function getOrgId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-ORG-ID');
}

//Get SpaceID Tag Value TODO: Delete?
function getSpaceId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-SPACE-ID');
}

//Get Instance ID  TODO: Delete?
function getInstanceId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-INSTANCE-ID');
}



// iterates through all database instances, getting their tags, their
function getAllDbInstances(filter, functionCallback) {
    var RdsArnPrefix = null,
        AwsAccountId = null,
        dbInstances = [];

    function addTagsToDBInstances(dbinstance, callback) {
        rds.listTagsForResource({
                'ResourceName': RdsArnPrefix + dbinstance.DBInstanceIdentifier
            },
            function(err, tags) {
                if (err) {
                    callback(err, null);
                } else {
                    if (tags) {
                        dbinstance.TagList = tags.TagList;
                    } else {
                        dbinstance.TagList = [];
                    }
                    callback(null, dbinstance);
                }
            });
    }

    //async is a module that runs in this case a series of tasks, each task runs in a series,
    // but exits if any of the tasks error, each task has a callback
    async.series([
            // Get AwsAccountId and RdsArnPrefix
            function(callback) {
                iam.getUser({}, function(err, data) {
                    var user,
                        colon = new RegExp(":");
                    if (err) {
                        console.log(err, err.stack);
                        callback(err, []);
                    } else {
                        user = data.User;
                        AwsAccountId = user.Arn.split(colon)[4];
                        RdsArnPrefix = 'arn:aws:rds:' + config.aws.Region + ':' + AwsAccountId + ':db:';
                        callback(null, user);
                    }
                });
            },

            // Get All RdsInstances
            function(callback) {
                var i = 0;

                rds.describeDBInstances({}).eachPage(function(err, page, done) {
                    if (err) {
                        callback(err, null);
                    } else if (page) {
                        if (page.DBInstances && page.DBInstances.length > 0) {
                            async.mapLimit(page.DBInstances, 2, addTagsToDBInstances, function(err, results) {
                                if (err) {
                                    callback(err, null);
                                } else {
                                    filter.filter(results, function(err, matches) {
                                        if (err) {
                                            callback(err, null);
                                        } else {
                                            for (i = 0; i < matches.length; i += 1) {
                                                dbInstances.push(matches[i]);
                                            }
                                            done();
                                        }
                                    });
                                }
                            });
                        } else {
                            done();
                        }
                    } else {
                        callback(null, dbInstances);
                    }
                });
            }
        ],
        function(err) {
            functionCallback(err, dbInstances);
        });
}

// filter to match on service instance id
function DbInstanceIdFilter(id) {
    this.filter = function(dbinstances, callback) {
        function matchInstanceIdTag(tag, callback) {
            callback(tag.Key === 'CF-AWS-RDS-INSTANCE-ID' && tag.Value === id);
        }

        function match(instance, callback) {
            async.filter(instance.TagList, matchInstanceIdTag, function(resultingArray) {
                callback(resultingArray.length > 0);
            });
        }

        async.filter(dbinstances, match, function(matchingDbInstances) {
            callback(null, matchingDbInstances);
        });
    };
}


// filter to select all of the  dbinstances
function DbInstanceNoFilter() {
    this.filter = function(dbinstances, callback) {

        function match(instance, callback) {
            var i, tag, serviceMatch = false,
                planMatch = false,
                orgMatch = false,
                spaceMatch = false;

            for (i = 0; i < instance.TagList.length; i += 1) {
                tag = instance.TagList[i];
                serviceMatch = serviceMatch || (tag.Key === 'CF-AWS-RDS-SERVICE-ID');
                planMatch = planMatch || (tag.Key === 'CF-AWS-RDS-PLAN-ID');
                orgMatch = orgMatch || (tag.Key === 'CF-AWS-RDS-ORG-ID');
                spaceMatch = spaceMatch || (tag.Key === 'CF-AWS-RDS-SPACE-ID');
            }
            callback(serviceMatch && planMatch && orgMatch && spaceMatch);
        }

        async.filter(dbinstances, match, function(matchingDbInstances) {
            callback(null, matchingDbInstances);
        });
    };
}

// filter to select all of dbinstances matching service, plan, organization and space.
function DbInstanceParameterFilter(params) {
    this.service_id = params.service_id;
    this.plan_id = params.plan_id;
    this.organization_guid = params.organization_guid;
    this.space_guid = params.space_guid;

    this.filter = function(dbinstances, callback) {

        function match(instance, callback) {
            var i, tag, serviceMatch = false,
                planMatch = false,
                orgMatch = false,
                spaceMatch = false;

            for (i = 0; i < instance.TagList.length; i += 1) {
                tag = instance.TagList[i];
                serviceMatch = serviceMatch || (tag.Key === 'CF-AWS-RDS-SERVICE-ID' && tag.Value === params.service_id);
                planMatch = planMatch || (tag.Key === 'CF-AWS-RDS-PLAN-ID' && tag.Value === params.plan_id);
                orgMatch = orgMatch || (tag.Key === 'CF-AWS-RDS-ORG-ID' && tag.Value === params.organization_guid);
                spaceMatch = spaceMatch || (tag.Key === 'CF-AWS-RDS-SPACE-ID' && tag.Value === params.space_guid);
            }
            callback(serviceMatch && planMatch && orgMatch && spaceMatch);
        }

        async.filter(dbinstances, match, function(matchingDbInstances) {
            callback(null, matchingDbInstances);
        });
    };
}

//generate an instance ID - TODO: Delete, instance ID is generated by caller, e.g. Cloud Foundry
function generateInstanceId(prefix) {
    if (prefix!=null) {
        return prefix.concat('-').concat((Math.floor(Date.now() / 100).toString(16)));
    } else {
        throw new Error("Database name is missing please specify name in your request");
    }
}


//generate an AWS management URL for instance - not to exposed to consumers - keep for testing purposes
function createDashboardUrl(params) {
    var dashboardUrl = Handlebars.compile('https://{{region}}.console.aws.amazon.com/rds/home?region={{region}}#dbinstance:id={{id}}');
    return {
        dashboard_url: dashboardUrl({
            region: aws.config.region,
            id: params.DBInstanceIdentifier
        })
    };
}

/**----------------------------------------------------
 * Retrieve root password for database server instance
 * TODO: Delete
 -----------------------------------------------------*/
var getCredentials = function getCredentials(instance, plan_id) {
    var credentials, hostname, port;

    if (instance.Endpoint) {
        hostname = instance.Endpoint.Address;
        port = instance.Endpoint.Port;
    }

    credentials = {
        'name': instance.DBName,
        'hostname': hostname,
        'host': hostname,
        'port': port,
        'user': instance.MasterUsername,
        'username': instance.MasterUsername,
        'password': getPassword(instance)
    };

    if (instance.Endpoint) {
        credentials.uri = urlTemplates[plan_id](credentials);
        credentials.jdbcUrl = "jdbc:".concat(credentials.uri);
    }

    return credentials;
};


/**-------------------------------------------------------------------------
 * This checks to ensure that broker api version is specified and supported
 * 
 * @param version
 * @returns {Function}
 --------------------------------------------------------------------------*/
function apiVersionChecker(version) {
    var header = 'x-broker-api-version';
    return function(request, response, next) {
        if (request.headers[header]) {
            var pattern = new RegExp('^' + version.major + '\\.\\d+$');
            if (!request.headers[header].match(pattern)) {
                console.log('Incompatible services API version: ' + request.headers[header]);
                response.status(412);
                next(new restify.PreconditionFailedError('Incompatible services API version'));
            }
        } else {
            console.log(header + ' is missing from the request');
        }
        next();
    };
}


/**
 *  Generates the configuration for the RDS instance based on client request
 *
 */
function configureRDSRequest(request){
    //var plan = loadPlan(request.params.plan_id);
    var params = {
        Tags: [{
            'Key': 'CF-AWS-RDS-SERVICE-ID',
            'Value': request.params.service_id
        },
            {
                'Key': 'CF-AWS-RDS-PLAN-ID',
                'Value': request.params.plan_id
            },
            {
                'Key': 'CF-AWS-RDS-ORG-ID',
                'Value': request.params.organization_guid
            },
            {
                'Key': 'CF-AWS-RDS-SPACE-ID',
                'Value': request.params.space_guid
            },
            {
                'Key': 'CF-AWS-RDS-INSTANCE-ID',
                'Value': request.params.id
            },
            {
                'Key': 'Costcenter',
                'Value': request.params.cost_center
            }],
        StackName: "inst-" + request.params.id + "org-" + request.params.organization_guid + "space-" + request.params.space_guid,
        Capabilities: ['CAPABILITY_IAM'],
        OnFailure: 'DELETE',
        Parameters: [{
            ParameterKey: 'DBName',
            ParameterValue: request.params.db_name
        },
            {
                ParameterKey: 'DBUser',
                ParameterValue: scommon.generatePassword(12)
            },
            {
                ParameterKey: 'DBPassword',
                ParameterValue: scommon.generatePassword(12)
            }],
        //ResourceTypes: ['AWS::RDS'],
        TemplateBody: JSON.stringify(loadPlan(request.params.plan_id)),
        TimeoutInMinutes: 20
    };
  return params;
}

/**
 *
 * TODO: Need to migrate to DB to support multiple brokers
 * TODO:Need cleanup mmechanism for instances that have been deleted
 */
function updateStatus(instanceId,org_Id,space_Id,stackId,status) {
    if (status=="deleting"){
        instances.delete(instanceId);
    }
    //check to see if it exists
    if (instanceId in instances) {
        //update its status
        instances[instanceId] = status;
    } else {
        //else new stack, track its status
        var attributes = {org_Id,space_Id,stackId,status};
        instances.set(instanceId, attributes);    //update status of using instance id and stackname
    }
}

/**-----------------------------------------------------------------
 *
 * Load the appropriate cloud formation based on the plan id
 *
 *------------------------------------------------------------------*/
function loadPlan(planId){
    var plan = "";

    for(var i=0; i < config.catalog.services[0].plans.length;i++){
        if (config.catalog.services[0].plans[i].id==planId){
            plan = require("./config/"+config.plans[planId].formation_name);
            return plan;
        }
    }
}

/**------------------------------------------------------------------
 *
 * Create RDS instance using appropriate cloud formation template
 *
 *------------------------------------------------------------------*/

function createRDSFromFormation(request, response, next, plan){
    var parameters = configureRDSRequest(request);
    cloudFormation.createStack(parameters, function(err, data) {
        if (err) {
            //check to see if there is a stackId present
            if(data!=null) {
                updateStatus(request.id, request.params.organization_guid, request.params.space_guid, data.StackId, "failed");
            }
            console.log(err, err.stack); // an error occurred
        }
        else {
            console.log(data);
            updateStatus(request.id,request.params.organization_guid,request.params.space_guid,data.StackId,"in progress");
            var params = {};
            cloudFormation.waitFor('stackCreateComplete', params, function (err, data) {
                if (err){
                    console.log(err, err.stack);
                    // an error occurred
                    updateStatus(request.id,request.params.organization_guid,request.params.space_guid,data.StackId,"failed");
                }
                else {
                    console.log(data);           // successful response
                    updateStatus(request.id,request.params.organization_guid,request.params.space_guid,data.StackId,"succeeded");
                }
                next();
            });
        }
        next();
    });
    next();
}

/**--------------------------------------------------------------------
 *
 * The following are required to provision new instances of RDS:
 *
 * 1) Plan ID
 * 2) Organization ID
 * 3) Space ID
 * 4) Database Name
 * 5) A flag indicating it accepts incomplete requests because of the
 *    longer provisioning period for RDS
 * 6) Cost Center
 * 7) Instance ID (generated by Cloud Controller in PCF environment)
 *
 ----------------------------------------------------------------------*/

function validateProvisioningRequest(request){
    var msg="";
    if(!request.params.hasOwnProperty("accepts_incomplete")|| !request.params.accepts_incomplete ){
        msg="-Client must support asynchronous provisioning";
    }
    if(!request.params.hasOwnProperty("plan_id") || !(request.params.plan_id in config.plans)){
        msg=msg+"-No plan id provided or plan id is invalid";
    }
    if(!request.params.hasOwnProperty("organization_guid")){
        msg=msg+"-No organization provided";
    }
    if(!request.params.hasOwnProperty("space_guid")){
        msg=msg+"-No space provided";
    }
    if(!request.params.hasOwnProperty("db_name")){
        msg=msg+"-No database server name provided";
    }
    if(!request.params.hasOwnProperty("cost_center")){
        msg=msg+"-No cost center provided";
    }
    if(!request.params.hasOwnProperty("id")){
        msg=msg+"-No instance id provided";
    }
    return msg;
}

server.get(/\/?.*/, restify.serveStatic({
    directory: './public',
    default: 'index.html'
}));

/** According to the spec, the JSON return message should include a description field. */
server.on('uncaughtException', function(req, res, route, err) {
    console.log(err, err.stack);
    res.send(500, {
        'code': 500,
        'description': err.message
    });
});

//TODO: Move to security common
function authenticate(credentials) {
    return function(request, response, next) {
        if (credentials.authUser || credentials.authPassword) {
            if (!(request.authorization && request.authorization.basic && request.authorization.basic.username === credentials.authUser && request.authorization.basic.password === credentials.authPassword)) {
                response.status(401);
                response.setHeader('WWW-Authenticate', 'Basic "realm"="' + server.name + '"');
                next(new restify.InvalidCredentialsError("invalid username or password"));
            } else {
                // authenticated!
            }
        } else {
            // no authentication required.
        }
        next();
    };
};

//checkConsistency();
urlTemplates = compileTemplates();

var port = Number(process.env.VCAP_APP_PORT || 5001);
server.listen(port, function() {
    console.log('%s listening at %s', server.name, server.url)
});
