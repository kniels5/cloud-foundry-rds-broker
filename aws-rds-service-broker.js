/**
 * This has been enahnced from the original version created by Mark van Holsteijn, Xebia Nederland B.V.
 *
 * Cloud Foundry Service Broker complyies to version 2.8 of the interface specification
 * http://docs.cloudfoundry.org/services/api.html
 *
 * It implements the following methods:
 *
 * 1) The catalog of services and plans is stored in the config/aws-rds-service-broker.json. This will be changed to
 *    leverage plans that are defined through a set of Cloud Formation templates with future releases
 *
 * 2) Provision: The service broker will create a Amazon RDS database instance, the following are added as tags to
 *    the provisioned instance:
 *      --> Org ID - this uniquely identifies the organization in PCF that requested the instance
 *      --> Space ID - this uniquely identifies the space in PCF that requested the instance
 *      --> Service ID - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB
 *      --> Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                        Cloud Controller
 *      --> Plan ID - this uniquely identifies the attributes of the instance, e.g. physical resources, iiops, etc
 *
 * 3) Bind: search for the specified service instance with a matching tag and return the credentials.
 * 
 * 4) Deprovision: search for the specified service instance with matching tag and deletes it.
 *
 * The bind does not keep any registration. The service broker is stateless: all information is stored in AWS.
 *
 * The catalog of services and plans is stored in the config/aws-rds-service-broker.json.
 *
 * For more information, check the README.md
 */


'use strict';

var config = require('./config/aws-rds-service-broker');

//TODO: Replace with DB like Redis/MariaDB in order to support multiple brokers
function binding(bindId, leaseId) {
    this.bindId = bindId;
    this.leaseId = leaseId;
}
function dbInstance(binding, orgId, spaceId, stackId, status, dbURL) {
    this.binding = binding;
    this.orgId = orgId;
    this.spaceId = spaceId;
    this.stackId = stackId;
    this.status = status;
    this.dbURL = dbURL;
}

var instances = new Map();


var generatePassword = require('password-generator');

//handles REST endpoint
var restify = require('restify');
var Handlebars = require('handlebars');

//aws api
var aws = require('aws-sdk');
aws.config.setPromisesDependency(require('bluebird'));

//used for creating outbound REST calls
var axios = require('axios');

//used for string & final manipulation
var S = require('string');
var fs = require('read-file');
var readRoleTemplate = "CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';GRANT SELECT ON <dbname>.* TO '{{name}}'@'%';";
var writeRoleTemplate = "CREATE USER '{{name}}'@'%' IDENTIFIED BY '{{password}}';GRANT ALTER,CREATE,INDEX,INSERT,SELECT,UPDATE ON <dbname>.* TO '{{name}}'@'%';";


/* following configs are determined by environment variables */
config.credentials = {};

/**
 *   Cloud Controller will authenticate to Broker with the credentials that were generated/created when
 *   the broker was installed in the foundation
 */
config.credentials.authUser = (process.env.SERVICE_BROKER_USERNAME);
config.credentials.authPassword = (process.env.SERVICE_BROKER_PASSWORD);

/**
 * The broker will create new instances in the defined region, e.g. US-EAST-1 (Discover Default)
 * AWS will ensure that for availability purposes that instances along with replicas are spread across subnets
 * which are located on different availability zones. Only applicable to plans where HA is an option
 *
 */
config.aws = {};
config.aws.Region = (process.env.AWS_REGION);
config.aws.DBSubnetGroupName = (process.env.AWS_DBSUBNET_GROUP_NAME);

aws.config.region = config.aws.Region;
var rds = new aws.RDS();
var iam = new aws.IAM();
var cloudFormation = new aws.CloudFormation({apiVersion: '2010-05-15'});



var urlTemplates = {};

/**-------------------------------------------------------
 * Create and configure the node server - restify module
 --------------------------------------------------------*/

var server = restify.createServer({
    name: 'aws-rds-service-broker'
});

//Create a handler(function) to ensure that the broker enforces a specific api version (2.8 is latest)
server.use(apiVersionChecker({
    'major': 2,
    'minor': 8
}));

server.use(restify.authorizationParser());
server.use(authenticateBrokerCaller(config.credentials, server));
server.use(restify.fullResponse());
server.use(restify.bodyParser());
server.use(restify.queryParser());
server.pre(restify.pre.userAgentConnection());

//--------------------End Server Configuration---------------------
 
//TODO: This is for the test UI, will need to altered for marketplace usage
function compileTemplates() {
    var i, p, id, str, result = {};
    for (i = 0; i < config.catalog.services.length; i += 1) {
        for (p = 0; p < config.catalog.services[i].plans.length; p += 1) {
            id = config.catalog.services[i].plans[p].id;
            str = config.plans[id].urlTemplate;
            result[id] = Handlebars.compile(str);
        }
    }
    return result;
}

/**--------------------------------------------------------------------------
 *
 * Map broker api /v2/catalog to a return of the catalog - this will return
 * the details for the plans configured in the json file
 *
 *--------------------------------------------------------------------------*/
server.get('/v2/catalog', function(request, response, next) {
    //catalog loaded from json file on server startup
    response.send(config.catalog);
    next();
});

/**---------------------------------------------------------------------------
 *
 * Determine the return status from the AWS Describe Stacks Call:
 *  1) Update the instance status appropriately or delete it if appropriate
 *  2) Return appropriate message to client
 *
 *---------------------------------------------------------------------------*/

function determineAWSReturnStatus(instanceId, data, response) {
    var status = data.Stacks[0].StackStatus;
    var returnState;
    switch (status) {
        case "CREATE_IN_PROGRESS":
            returnState = "in progress";
            instances.get(instanceId).status = "in progress";
            break;
        case "CREATE_FAILED":
            returnState = "failed";
            instances.get(instanceId).status = "failed";
            break;
        case "CREATE_COMPLETE":
            returnState = "succeeded";
            instances.get(instanceId).status = "succeeded";
            break;
        case "DELETE_IN_PROGRESS":
            returnState = "in progress";
            instances.get(instanceId).status = "in progress";
            break;
        case "DELETE_FAILED":
            //want to try multiple times to delete to avoid orphans
            if (instances.has(instanceId) & instances.get(instance).state == "in progress") {
                //first attempt at deleting, force cloud controller to try again
                instances.get(instanceId).status = "deleting";
                returnState = "in progress";
            }
            else {
                returnState = "failed";
                instances.get(instanceId).status = "failed";
            }
            break;
        case "DELETE_COMPLETE":
            returnState = "succeeded";
            instances.get(instanceId).status = "succeeded";
            break;
        default:
            instances.get(instanceId).status = "succeeded";
            returnState = "succeeded";
    }
    var returnMsg = {state: returnState};
    response.send(200, returnMsg);
}

/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id>/last_operation
 *
 * This will support by client (e.g. cloud controller) to see the state of the last operation
 *
 * AWS provisioning will be asynchronous so binding will have to be a subsequent step, i.e. provisioning will create
 * the root credentials for the database, but an app account will be generated during the binding call
 *
 * See http://docs.cloudfoundry.org/services/api.html for more info
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.put('/v2/service_instances/:instance_id/last_operation', function (request, response) {
    if (!request.params.hasOwnProperty("instance_id")) {
        response.send(500, "The instance was not specified");
        next();
    }
    else if (!instances.has(request.params.instance_id)) {
        //if not found assume it was deleted successfully
        //cloud controller not expecting a response body
        response.send(410);
    }
    else {
        var stackName = instances.get(request.params.instance_id).stackId;
        var params = {StackName: stackName};

        cloudFormation.describeStacks(params, function (err, data) {
            if (err != null) {
                console.log(err, err.stack);
                // an error occurred - dont update status
                //TODO: Figure out cloud controllers response to various error codes
                response.send(500, err.code + ":" + err.stack);
            }
            else {
                // successful response
                console.log(data);
                determineAWSReturnStatus(request.params.instance_id, data, response);
            }
        });
    }
});
/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id> to provisioning of new instance based on passed in parameters
 * AWS provisioning will be asynchronous so binding will have to be a subsequent step
 *              1) Org ID - this uniquely identifies the organization in PCF that requested the instance
 *              2) Space ID - this uniquely identifies the space in PCF that requested the instance
 *              3) Service ID - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB
 *              4) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller and is part of url not json request params
 *              5) Plan ID - this uniquely identifies the attributes of the instance, e.g. physical resources, iiops,etc
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.put('/v2/service_instances/:id', function(request, response, next) {
    var msg = validateProvisioningRequest(request);
    if(msg!=""){
        response.send(422,msg);
        next();
    }
    else {
        var vaultAxiosClient = axios.create({
            baseURL: process.env.VAULT_ADDR
        });
        vaultAxiosClient.defaults.headers.post['Content-Type'] = 'application/json';
        createRDSFromFormation(request, response, next, config.plans[request.params.plan_id], vaultAxiosClient);
    }
});

//---------------------------------------End /v2/service_instances/:id  broker API--------------------------------------

/**---------------------------------------------------------------------------------------------------------------------
 *
 * Map broker api /v2/service_instances/<instance id> to de-provisioning of existing instance
 *              1) Service ID - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB
 *              2) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller and is part of url not json request params
 *              3) Plan ID - this uniquely identifies the attributes of the instance, e.g. physical resources, iiops,etc
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 * TODO: Once vault is integrated will have to remove credentials associated with this instance
 ---------------------------------------------------------------------------------------------------------------------*/
server.del('/v2/service_instances/:instance_id', function (request, response) {

    //must support async calls
    if (!request.params.hasOwnProperty("accepts_incomplete") || !request.params.accepts_incomplete) {
        var msg = {
            error: "AsyncRequired",
            description: "This service plan requires client support for asynchronous service operations."
        };
        response.send(422, msg);
    }

    //must specify the instance to delete, this should never happen with Cloud Controller making requests
    if (!request.params.hasOwnProperty("instance_id")) {
        response.send(500, "The instance was not specified");
    }
    else if (!instances.has(request.params.instance_id)) {
        //if not found assume it was deleted successfully
        //cloud controller not expecting a response body
        response.send(410);
    }
    //the instance exists
    else {
        //this should only ever be executed once, since deletes are async, "last_operation" would be subsequently
        //called so some of this logic could be removed since cloud controller shouldnt call delete twice for same
        //instance
        var stackName = instances.get(request.params.instance_id).stackId;
        var status = instances.get(request.params.instance_id).status;
        var params = {StackName: stackName};
        var deleteStackPromise = cloudFormation.deleteStack(parameters).promise();
        deleteStackPromise.then(function (data) {
            // successful response - mark the status as "deleting"
            console.log(data);
            instances.get(request.params.instance_id).status = "deleting";
            response.send(202);

        })
            .catch(function (error) {
            //error deleting, assume that the stack doesnt exist
                console.log(error);
                // an error occurred - if the previous status is "deleting" remove the instance
                if (status == "deleting") {
                    instances.delete(request.params.instance_id);
                    response.send(200);
                }
                else {
                    //wasn't previously "deleting" so update to deleting and force cloud controller to try again
                    instances.get(request.params.instance_id).status = "deleting";
                    response.send(202);
                }
        });
    }
});

//---------------------------------------End /v2/service_instances/:id broker API---------------------------------------

/**---------------------------------------------------------------------------------------------------------------------
 * TODO:This is not part of the official broker API and can eventually be removed
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.get('/v2/service_instances', function (request, response) {
    response.send(500, "Unsupported function");
});

//---------------------------------------end of /v2/service_instances API-----------------------------------------------

/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id> /service_bindings/<bind id> to bind application to existing
 * service. AWS provisioning will be asynchronous so binding will have to be a subsequent step
 *              1) Service ID (optional) - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB. BODY
 *              2) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller. URL
 *              3) Plan ID (optional) - this uniquely identifies the attributes of the instance,
 *                                      e.g. physical resources, iiops,etc. BODY
 *              4) App_GUID - this is the guid of the application that is being bound to the service. BODY
 *              5) Bind ID - this is an id that is generated by the Cloud Controller, it must be tracked such that an
 *                           unbind correctly deletes credentials associated with a given service. URL
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 *  TODO: Change credential management to vault, flow should be:
 *          1) Ensure instance id exists
 *          2) Check bind id and do the following:
 *              a) If bind id is non-unique, generate new set of credentials, i.e. rebind
 *              b) If bind id is unique, generate new set of credentials
 *              c) Response will include the following
 *                  --> uri (jdbc:mysql://<hostname>:<port>/<dbname>
 *                  --> hostname
 *                  --> port
 *                  --> username
 *                  --> password
 *          3) Tag RDS instance with bind id
 *          4) Tag vault credentials with bind id
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.put('/v2/service_instances/:instance_id/service_bindings/:binding_id', function (req, response) {
    var reply = {};
    var instanceID = request.params.instance_id;
    var bindID = request.params.binding_id;

    //must specify the instance to delete, this should never happen with Cloud Controller making requests
    if (instanceID != null) {
        response.send(422, "The instance was not specified");
    }
    else if (!instances.has(instanceID)) {
        //instance doesnt exist
        response.send(422, "The instance you are attempting to bind to doesnt exist");
    }
    else if (bindID == null) {
        response.send(422, "No binding id specified");
    }
    var vaultAxiosClient = axios.create({
        baseURL: process.env.VAULT_ADDR
    });
    vaultAxiosClient.defaults.headers.post['Content-Type'] = 'application/json';

    //200/409 - Binding already exists, none generated
    var instanceBindID = instances.get(request.params.instance_id).bindId;
    if (instanceBindID != null && instanceBindID = bindID) {
        //binding already exists
        response.send(200, " Binding already exists");
    }
    else {
        //binding doesnt exists create it - 201
        var path = process.env.VAULT_API_VERSION +;
        var
            };

});

//-----------------------end of /v2/service_instances/:instance_id/service_bindings/:binding_id-------------------------

//-------------------------------end /v2/service_instances/:instance_id/service_bindings/:id----------------------------

//Retrieve AWS Tag Value TODO: Delete?
function getTagValue(instance, key) {
    var i, tag;
    for (i = 0; i < instance.TagList.length; i += 1) {
        tag = instance.TagList[i];
        if (tag.Key === key) {
            return tag.Value;
        }
    }
    return undefined;
}

//Get ServiceID Tag Value TODO: Delete?
function getServiceId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-SERVICE-ID');
}

//Get PlanID Tag Value TODO: Delete?
function getPlanId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-PLAN-ID');
}

//Get OrgID Tag Value TODO: Delete?
function getOrgId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-ORG-ID');
}

//Get SpaceID Tag Value TODO: Delete?
function getSpaceId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-SPACE-ID');
}

//Get Instance ID  TODO: Delete?
function getInstanceId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-INSTANCE-ID');
}


//generate an instance ID - TODO: Delete, instance ID is generated by caller, e.g. Cloud Foundry
function generateInstanceId(prefix) {
    if (prefix!=null) {
        return prefix.concat('-').concat((Math.floor(Date.now() / 100).toString(16)));
    } else {
        throw new Error("Database name is missing please specify name in your request");
    }
}


//generate an AWS management URL for instance - not to exposed to consumers - keep for testing purposes
function createDashboardUrl(params) {
    var dashboardUrl = Handlebars.compile('https://{{region}}.console.aws.amazon.com/rds/home?region={{region}}#dbinstance:id={{id}}');
    return {
        dashboard_url: dashboardUrl({
            region: aws.config.region,
            id: params.DBInstanceIdentifier
        })
    };
}

/**----------------------------------------------------
 * Retrieve root password for database server instance
 * TODO: Delete
 -----------------------------------------------------*/
var getCredentials = function getCredentials(instance, plan_id) {
    var credentials, hostname, port;

    if (instance.Endpoint) {
        hostname = instance.Endpoint.Address;
        port = instance.Endpoint.Port;
    }

    credentials = {
        'name': instance.DBName,
        'hostname': hostname,
        'host': hostname,
        'port': port,
        'user': instance.MasterUsername,
        'username': instance.MasterUsername,
        'password': getPassword(instance)
    };

    if (instance.Endpoint) {
        credentials.uri = urlTemplates[plan_id](credentials);
        credentials.jdbcUrl = "jdbc:".concat(credentials.uri);
    }

    return credentials;
};


/**-------------------------------------------------------------------------
 *
 * This checks to ensure that broker api version is specified and supported
 * 
 * @param version
 * @returns {Function}
 --------------------------------------------------------------------------*/
function apiVersionChecker(version) {
    var header = 'x-broker-api-version';
    return function(request, response, next) {
        if (request.headers[header]) {
            var pattern = new RegExp('^' + version.major + '\\.\\d+$');
            if (!request.headers[header].match(pattern)) {
                console.log('Incompatible services API version: ' + request.headers[header]);
                response.status(412);
                next(new restify.PreconditionFailedError('Incompatible services API version'));
            }
        } else {
            console.log(header + ' is missing from the request');
        }
        next();
    };
}


/**--------------------------------------------------------------------
 *
 *  Generates the configuration for the RDS instance based on
 *  client request
 *
 *--------------------------------------------------------------------*/
function configureRDSRequest(request){
    //var plan = loadPlan(request.params.plan_id);
    // Generate the new databases admin/root account and place into Vault
    var creds = generateDBRootCredentials(request.params.id);
    var params = {
        Tags: [{
            'Key': 'CF-AWS-RDS-SERVICE-ID',
            'Value': request.params.service_id
        },
            {
                'Key': 'CF-AWS-RDS-PLAN-ID',
                'Value': request.params.plan_id
            },
            {
                'Key': 'CF-AWS-RDS-ORG-ID',
                'Value': request.params.organization_guid
            },
            {
                'Key': 'CF-AWS-RDS-SPACE-ID',
                'Value': request.params.space_guid
            },
            {
                'Key': 'CF-AWS-RDS-INSTANCE-ID',
                'Value': request.params.id
            },
            {
                'Key': 'Costcenter',
                'Value': request.params.cost_center
            }],
        StackName: "inst" + request.params.id + "-org" + request.params.organization_guid + "-space" + request.params.space_guid,
        Capabilities: ['CAPABILITY_IAM'],
        OnFailure: 'DELETE',
        Parameters: [{
            ParameterKey: 'DBName',
            ParameterValue: request.params.db_name
        },
            {
                ParameterKey: 'DBUser',
                ParameterValue: creds.userID
            },
            {
                ParameterKey: 'DBPassword',
                ParameterValue: creds.password
            }],
        //ResourceTypes: ['AWS::RDS'],
        TemplateBody: JSON.stringify(loadPlan(request.params.plan_id)),
        TimeoutInMinutes: 20
    };
  return params;
}

/**-----------------------------------------------------------------
 *
 * Load the appropriate cloud formation based on the plan id
 *
 *------------------------------------------------------------------*/
function loadPlan(planId){
    var plan = "";

    for(var i=0; i < config.catalog.services[0].plans.length;i++){
        if (config.catalog.services[0].plans[i].id==planId){
            plan = require("./config/"+config.plans[planId].formation_name);
            return plan;
        }
    }
}

/**------------------------------------------------------------------
 *
 * Create RDS instance using appropriate cloud formation template
 *
 *------------------------------------------------------------------*/

function createRDSFromFormation(request, response, next, plan, vaultClient) {
    var parameters = configureRDSRequest(request);
    var createStackPromise = cloudFormation.createStack(parameters).promise();


    /*--------------------------------------------------------
     * 1.  Create the stack which includes RDS resource
     *-------------------------------------------------------*/
    createStackPromise.then(function (data) {
        console.log(data);
        //binding(bindId,leaseId),orgId,spaceId,stackId,status,dbURL;
        var dbInstance = new dbInstance(new binding(null, null), request.params.organization_guid, request.params.space_guid, data.StackId, "in progress"
            , null);
        instances.put(request.params.id, dbInstance);

        /*---------------------------------------------------------------
         * 2. Set up a wait for the provisioning completion, stack has been
         * created, wait for the RDS completion notification
         *--------------------------------------------------------------*/
        var opts = {StackName: data.StackId};
        cloudFormation.waitFor('stackCreateComplete', opts).promise().then(function (data) {
            console.log(data);

            //create the mysql credentials, etc for new instance
            configureVaultMySQL(parameters, request.params.organization_guid, request.params.id, vaultClient, data);

            //store the returned jdbc url
            var jdbcURLTemplate = S(stackData.Stacks[0].Outputs[0].OutputValue);
            dbInstance = instances.get(request.params.id);
            dbInstance.dbURL = jdbcURLTemplate;
            dbInstance.status = "succeeded";

        });


        response.send(202, "Provisioning request successful");
    })
        .catch(function (error, data) {
            console.log(error, error.stack); // an error occurred
            //check to see if there is a stackId present
            if (data != null) {
                var dbInstance = instances.get(request.params);
                if (dbInstance != null) {
                    dbInstance.status = "failed";
                }
                if (data.statusCode == "400") {
                    response.send(409);
                }
                else {
                    response.send(501, data.message);
                }
            }
        });
}
/**
 *
 *  Mount new MySQL Secret Backend
 *
 *   1) Create new MySQL Mounts
 *      for Vault, e.g. mysql-dev-<groupid>-<instanceId>
 *   2) Configure connection to new instance
 *   3) Create read and write roles
 *
 */
function configureVaultMySQL(awsParameters, groupid, instanceID, vaultClient, stackData) {

    /*----------------------------------------------------
     * 1.  Authenticate to Vault and get new client token
     *---------------------------------------------------*/
    var vaultPath = process.env.VAULT_API_VERSION + process.env.VAULT_APPID_PATH + process.env.VAULT_APPID;
    var payload = {user_id: process.env.VAULT_USERID};
    vaultClient.post(vaultPath, {
        user_id: process.env.VAULT_USERID
    })
        .then(function (response) {
            /*---------------------------------------------------------------------------------
             * 2. Successful authentication create new mount point for newly created instance
             *--------------------------------------------------------------------------------*/
            console.log(response);
            vaultClient.defaults.headers.common['X-Vault-Token'] = response.data.auth.client_token;

            var mountPoint = process.env.VAULT_MYSQL_MOUNT_BASE + "-" + process.env.BROKER_ENV + "-" + groupid + "-" + instanceID;
            var path = process.env.VAULT_API_VERSION + process.env.VAULT_MOUNT_URL + mountPoint;
            var options = {
                type: "mysql",
                description: "MySQL Mount for Group:" + groupid + " Instance:" + instanceID
            };

            vaultClient.post(path, options)
                .then(function (response) {
                    console.log(response);
                    /*---------------------------------------------------------------------------
                     * 3. Create new connection configuration for new mount created in step #2.
                     *    The connection url comes from the response from AWS upon stack creation
                     *    completion
                     * --------------------------------------------------------------------------*/

                    //get the root credentials for the new instance
                    var dbInstanceCredentials = {
                        userID: awsParameters.Parameters[1].ParameterValue,
                        password: awsParameters.Parameters[2].ParameterValue
                    };

                    //get the hostname of the new RDS instance
                    var partialURL = S(stackData.Stacks[0].Outputs[0].OutputValue).between('//', '/');
                    var fullURL = dbInstanceCredentials.userID + ":" + dbInstanceCredentials.password + "@tcp(" + partialURL + ")/" + awsParameters.Parameters[0].ParameterValue;

                    var path = process.env.VAULT_API_VERSION + mountPoint + process.env.VAULT_MYSQL_CONFIG_BASE;
                    var options = {
                        connection_url: fullURL,
                        verify_connection: true
                    };
                    vaultClient.post(path, options)
                        .then(function (response) {
                            console.log(response);
                            /*------------------------------------------
                             * 4a. Create new read role for new database
                             * ----------------------------------------*/
                            var sql = S(readRoleTemplate).replace('<dbname>', awsParameters.Parameters[0].ParameterValue);
                            var path = process.env.VAULT_API_VERSION + mountPoint + process.env.READ_ROLE_PATH;

                            vaultClient.post(path, {"sql": sql.toString()})
                                .then(function (response) {
                                    console.log(response);

                                })
                                .catch(function (error) {
                                    //TODO: What to do upon role creation failure?
                                    console.log(error);
                                });
                            /*--------------------------------------------
                             * 4b. Create new write role for new database
                             * -------------------------------------------*/
                            var sql = S(writeRoleTemplate).replace('<dbname>', awsParameters.Parameters[0].ParameterValue);
                            var path = process.env.VAULT_API_VERSION + mountPoint + process.env.WRITE_ROLE_PATH;
                            vaultClient.post(path, {"sql": sql.toString()})
                                .then(function (response) {
                                    console.log(response);

                                })
                                .catch(function (error) {
                                    //TODO: What to do upon role creation failure?
                                    console.log(error);
                                });

                        });
                })
                .catch(function (error) {
                    //TODO: What to do upon failure of the mount?
                    console.log(error);
                });
        })
        .catch(function (error) {
            //TODO: What to do upon failure of the authentication?
            console.log(error);
        });
}

/**-------------------------------------------------------------------------
 * Broker uses basic authentication to ensure the API requestor is known
 * These credentials are generated when pushing broker, are encrypted and
 * stored in Cloud Controller database and passed from Cloud Controller
 * to broker during API invocation
 *
 * @param credentials
 * @returns {Function}
 --------------------------------------------------------------------------*/

function authenticateBrokerCaller(credentials) {
    return function (request, response, next) {
        if (credentials.authUser || credentials.authPassword) {
            if (!(request.authorization && request.authorization.basic && request.authorization.basic.username === credentials.authUser && request.authorization.basic.password === credentials.authPassword)) {
                response.status(401);
                response.setHeader('WWW-Authenticate', 'Basic "realm"="' + server.name + '"');
                next(new restify.InvalidCredentialsError("invalid username or password"));
            } else {
                // authenticated!
            }
        } else {
            // no authentication required.
        }
        next();
    };
}

/**--------------------------------------------------------------------
 *
 * The following are required to provision new instances of RDS:
 *
 * 1) Plan ID
 * 2) Organization ID
 * 3) Space ID
 * 4) Database Name
 * 5) A flag indicating it accepts incomplete requests because of the
 *    longer provisioning period for RDS
 * 6) Cost Center
 * 7) Instance ID (generated by Cloud Controller in PCF environment)
 *
 ----------------------------------------------------------------------*/

function validateProvisioningRequest(request){
    var msg="";
    if(!request.params.hasOwnProperty("accepts_incomplete")|| !request.params.accepts_incomplete ){
        msg="-Client must support asynchronous provisioning";
    }
    if(!request.params.hasOwnProperty("plan_id") || !(request.params.plan_id in config.plans)){
        msg=msg+"-No plan id provided or plan id is invalid";
    }
    if(!request.params.hasOwnProperty("organization_guid")){
        msg=msg+"-No organization provided";
    }
    if(!request.params.hasOwnProperty("space_guid")){
        msg=msg+"-No space provided";
    }
    if(!request.params.hasOwnProperty("db_name")){
        msg=msg+"-No database server name provided";
    }
    if(!request.params.hasOwnProperty("cost_center")){
        msg=msg+"-No cost center provided";
    }
    if(!request.params.hasOwnProperty("id")){
        msg=msg+"-No instance id provided";
    }
    return msg;
}

server.get(/\/?.*/, restify.serveStatic({
    directory: './public',
    default: 'index.html'
}));

/** According to the spec, the JSON return message should include a description field. */
server.on('uncaughtException', function(req, res, route, err) {
    console.log(err, err.stack);
    res.send(500, {
        'code': 500,
        'description': err.message
    });
});

//checkConsistency();
urlTemplates = compileTemplates();

var port = Number(process.env.VCAP_APP_PORT || 5001);
server.listen(port, function() {
    console.log('%s listening at %s', server.name, server.url)
});

function authenticateViaAPPID(vaultClient) {
    var vaultPath = process.env.VAULT_API_VERSION + process.env.VAULT_APPID_PATH + process.env.VAULT_APPID;
    var payload = {user_id: process.env.VAULT_USERID};
    vaultClient.post(vaultPath, {
        user_id: process.env.VAULT_USERID
    })
        .then(function (response) {
            //if successful add the Vault Token to list of headers for subsequent calls
            console.log(response);
            vaultClient.defaults.headers.common['X-Vault-Token'] = response.data.auth.client_token;
        })
        .catch(function (error) {
            console.log(error);
        });
}
/**
 *  TODO: Need to arrive at a password generation mechanism
 *  This will be used by both original provisioning for generating root account as well as for bind/re-bind.
 *  The resulting credential will be stored in vault
 *
 */
function generateDBRootCredentials(instanceID) {
    var creds = {
        userID: "",
        password: ""
    };
    creds.userID = "brokered" + instanceID;
    creds.password = generatePassword(24, false, /[\d]/);
    return creds;
}


