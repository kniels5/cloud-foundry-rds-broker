/**
 * This has been enahnced from the original version created by Mark van Holsteijn, Xebia Nederland B.V.
 *
 * Cloud Foundry Service Broker complyies to version 2.8 of the interface specification
 * http://docs.cloudfoundry.org/services/api.html
 *
 * It implements the following methods:
 *
 * 1) The catalog of services and plans is stored in the config/aws-rds-service-broker.json. This will be changed to
 *    leverage plans that are defined through a set of Cloud Formation templates with future releases
 *
 * 2) Provision: The service broker will create a Amazon RDS database instance, the following are added as tags to
 *    the provisioned instance:
 *      --> Org ID - this uniquely identifies the organization in PCF that requested the instance
 *      --> Space ID - this uniquely identifies the space in PCF that requested the instance
 *      --> Service ID - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB
 *      --> Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                        Cloud Controller
 *      --> Plan ID - this uniquely identifies the attributes of the instance, e.g. physical resources, iiops, etc
 *
 * 3) Bind: search for the specified service instance with a matching tag and return the credentials.
 * 
 * 4) Deprovision: search for the specified service instance with matching tag and deletes it.
 *
 * The bind does not keep any registration. The service broker is stateless: all information is stored in AWS.
 *
 * The catalog of services and plans is stored in the config/aws-rds-service-broker.json.
 *
 * For more information, check the README.md
 */


'use strict';

/**
 * Declare All Dependencies
 */
class VaultClient {
    constructor() {
        this.clientToken = "";
        this.restifyClient = null;
    }

    isAuthenticated() {
        if (this.clientToken == "") {
            return false;
        }
        return true;
    }

    configureRestifyClient() {
        var options = {
            url: process.env.VAULT_ADDR,
            //headers: {
            //        'X-VAULT-TOKEN':this.clientToken
            //}
        };
        this.restifyClient = restify.createJSONClient(options);
    }
}
var config = require('./config/aws-rds-service-broker');
//TODO: Replace with DB like Redis/MariaDB in order to support mutiple brokers
var instances = {};
var generatePassword = require('password-generator');
var assert = require('assert');
var restify = require('restify');
var async = require('async');
var Handlebars = require('handlebars');
var aws = require('aws-sdk');
var AsyncPolling = require('async-polling');
//var Vaulted = require('vaulted');
var axios = require('axios');

/* following configs are determined by environment variables */
config.credentials = {};

/**
 *   Cloud Controller will authenticate to Broker with the credentials that were generated/created when
 *   the broker was installed in the foundation
 */
config.credentials.authUser = (process.env.SERVICE_BROKER_USERNAME);
config.credentials.authPassword = (process.env.SERVICE_BROKER_PASSWORD);

/**
 * The broker will create new instances in the defined region, e.g. US-EAST-1 (Discover Default)
 * AWS will ensure that for availability purposes that instances along with replicas are spread across subnets
 * which are located on different availability zones. Only applicable to plans where HA is an option
 *
 */
config.aws = {};
config.aws.Region = (process.env.AWS_REGION);
config.aws.DBSubnetGroupName = (process.env.AWS_DBSUBNET_GROUP_NAME);

aws.config.region = config.aws.Region;
var rds = new aws.RDS();
var iam = new aws.IAM();
var cloudFormation = new aws.CloudFormation({apiVersion: '2010-05-15'});



var urlTemplates = {};

/**-------------------------------------------------------
 * Create and configure the node server - restify module
 --------------------------------------------------------*/

var server = restify.createServer({
    name: 'aws-rds-service-broker'
});

//Create a handler(function) to ensure that the broker enforces a specific api version (2.8 is latest)
server.use(apiVersionChecker({
    'major': 2,
    'minor': 8
}));

server.use(restify.authorizationParser());
server.use(authenticateBrokerCaller(config.credentials, server));
server.use(restify.fullResponse());
server.use(restify.bodyParser());
server.use(restify.queryParser());
server.pre(restify.pre.userAgentConnection());

//--------------------End Server Configuration---------------------
 
//TODO: This is for the test UI, will need to altered for marketplace usage
function compileTemplates() {
    var i, p, id, str, result = {};
    for (i = 0; i < config.catalog.services.length; i += 1) {
        for (p = 0; p < config.catalog.services[i].plans.length; p += 1) {
            id = config.catalog.services[i].plans[p].id;
            str = config.plans[id].urlTemplate;
            result[id] = Handlebars.compile(str);
        }
    }
    return result;
}

/**--------------------------------------------------------------------------
 *
 * Map broker api /v2/catalog to a return of the catalog - this will return
 * the details for the plans configured in the json file
 *
 *--------------------------------------------------------------------------*/
server.get('/v2/catalog', function(request, response, next) {
    //catalog loaded from json file on server startup
    response.send(config.catalog);
    next();
});

function composeResponse(instanceId, status, response, data) {
    var returnMsg;
    updateStatus(instanceId, null, null, null, status);
    returnMsg = {state: status};
    //returnMsg.description= data.Message;
    response.send(200, returnMsg);
}
/**---------------------------------------------------------------------------
 *
 * Determine the return status from the AWS Describe Stacks Call:
 *  1) Update the instance status appropriately or delete it if appropriate
 *  2) Return appropriate message to client
 *
 *---------------------------------------------------------------------------*/

function determineAWSReturnStatus(instanceId, data, response) {
    var status = data.Stacks[0].StackStatus;

    switch (status) {
        case "CREATE_IN_PROGRESS":
            composeResponse(instanceId, "in progress", response, data);
            break;
        case "CREATE_FAILED":
            composeResponse(instanceId, "failed", response, data);
            break;
        case "CREATE_COMPLETE":
            composeResponse(instanceId, "succeeded", response, data);
            break;
        case "DELETE_IN_PROGRESS":
            composeResponse(instanceId, "in progress", response, data);
            break;
        case "DELETE_FAILED":
            //want to try multiple times to delete to avoid orphans
            if (instances[instanceId].state == "in progress") {
                //first attempt at deleting, force cloud controller to try again
                updateStatus(instanceId, null, null, null, "deleting");
                var returnMsg = {state: "in progress"};
                response.send(200, returnMsg);
            }
            else {
                composeResponse(instanceId, "failed", response, data);
            }
            break;
        case "DELETE_COMPLETE":
            composeResponse(instanceId, "succeeded", response, data);
            break;
        default:
            composeResponse(instanceId, "failed", response, data);
    }
}

/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id>/last_operation
 *
 * This will support by client (e.g. cloud controller) to see the state of the last operation
 *
 * AWS provisioning will be asynchronous so binding will have to be a subsequent step, i.e. provisioning will create
 * the root credentials for the database, but an app account will be generated during the binding call
 *
 * See http://docs.cloudfoundry.org/services/api.html for more info
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.put('/v2/service_instances/:instance_id/last_operation', function(request, response, next) {
    if (!request.params.hasOwnProperty("instance_id")) {
        response.send(500, "The instance was not specified");
        next();
    }
    else if (!(request.params.instance_id in instances)) {
        //if not found assume it was deleted successfully
        //cloud controller not expecting a response body
        response.send(410);
        next();
    }
    else {
        var stackName = instances[request.params.instance_id].stackId;
        var params = {StackName: stackName};

        cloudFormation.describeStacks(params, function (err, data) {
            if (err != null) {
                console.log(err, err.stack);
                // an error occurred - dont update status
                //TODO: Figure out cloud controllers response to various error codes
                response.send(500, err.code + ":" + err.stack);
            }
            else {
                // successful response
                console.log(data);
                determineAWSReturnStatus(request.params.instance_id, data, response);
            }
        });
        next();
    }
});
/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id> to provisioning of new instance based on passed in parameters
 * AWS provisioning will be asynchronous so binding will have to be a subsequent step
 *              1) Org ID - this uniquely identifies the organization in PCF that requested the instance
 *              2) Space ID - this uniquely identifies the space in PCF that requested the instance
 *              3) Service ID - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB
 *              4) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller and is part of url not json request params
 *              5) Plan ID - this uniquely identifies the attributes of the instance, e.g. physical resources, iiops,etc
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.put('/v2/service_instances/:id', function(request, response, next) {
    var msg = validateProvisioningRequest(request);
    var vaultClient = new VaultClient();
    vaultClient.configureRestifyClient();

    /**testing vaulted client
     var myVault = new Vaulted({
        vault_host: 'http://52.41.9.191',
            vault_port: 8200,
            vault_ssl: false
    });

     myVault.setToken(process.env.VAULT_TOKEN);
     var status = {sealed:false};
     myVault.setStatus(status);

     myVault.prepare()
     .then(function () {
            console.log('Vault is now ready!');
        });
     myVault.createAuthMount('app-id');

     var options = {user_id:'cloud-controller-cfd2',
                   app_id:'cfd2-rds-broker'};
     var loginPromise = myVault.appLogin(options,'app-id');*/
    var vaultAxiosClient = axios.create({
        baseURL: process.env.VAULT_ADDR

    });

    if(msg!=""){
        response.send(422,msg);
        next();
    }
    else {
        createRDSFromFormation(request, response, next, config.plans[request.params.plan_id], vaultClient);
    }
});

//---------------------------------------End /v2/service_instances/:id  broker API--------------------------------------

/**---------------------------------------------------------------------------------------------------------------------
 *
 * Map broker api /v2/service_instances/<instance id> to de-provisioning of existing instance
 *              1) Service ID - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB
 *              2) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller and is part of url not json request params
 *              3) Plan ID - this uniquely identifies the attributes of the instance, e.g. physical resources, iiops,etc
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 * TODO: Once vault is integrated will have to remove credentials associated with this instance
 ---------------------------------------------------------------------------------------------------------------------*/
server.del('/v2/service_instances/:instance_id', function (request, response) {

    //must support async calls
    if (!request.params.hasOwnProperty("accepts_incomplete") || !request.params.accepts_incomplete) {
        var msg = {
            error: "AsyncRequired",
            description: "This service plan requires client support for asynchronous service operations."
        };
        response.send(422, msg);
        return;
    }

    //must specify the instance to delete, this should never happen with Cloud Controller making requests
    if (!request.params.hasOwnProperty("instance_id")) {
        response.send(500, "The instance was not specified");
    }
    else if (!(request.params.instance_id in instances)) {
        //if not found assume it was deleted successfully
        //cloud controller not expecting a response body
        response.send(410);
    }
    //the instance exists
    else {
        //this should only ever be executed once, since deletes are async, "last_operation" would be subsequently
        //called so some of this logic could be removed since cloud controller shouldnt call delete twice for same
        //instance
        var stackName = instances[request.params.instance_id].stackId;
        var status = instances[request.params.instance_id].status;
        var params = {StackName: stackName};
        cloudFormation.deleteStack(params, function (err, data) {
            //error deleting, assume that the stack doesnt exist
            if (err != null) {
                console.log(err, err.stack);
                // an error occurred - if the previous status is "deleting" remove the instance
                if (status == "deleting") {
                    updateStatus(request.params.instance_id, null, null, "remove");
                    response.send(200);
                }
                else {
                    //wasn't previously "deleting" so update to deleting and force cloud controller to try again
                    updateStatus(request.params.instance_id, null, null, "deleting");
                    response.send(202);
                }
            }
            else {
                // successful response - mark the status as "deleting"
                console.log(data);
                updateStatus(request.params.instance_id, null, null, "deleting");
                response.send(202);
            }
        });
    }
});

//---------------------------------------End /v2/service_instances/:id broker API---------------------------------------

/**---------------------------------------------------------------------------------------------------------------------
 * TODO:This is not part of the official broker API and can eventually be removed
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.get('/v2/service_instances', function(request, response, next) {
    getAllDbInstances(new DbInstanceNoFilter(), function(err, allDatabaseInstances) {
        if (!err) {
            async.map(allDatabaseInstances, function(instance, callback) {
                    var result = {};
                    result.id = getInstanceId(instance);
                    result.service_id = getServiceId(instance);
                    result.plan_id = getPlanId(instance);
                    result.organization_guid = getOrgId(instance);
                    result.space_guid = getSpaceId(instance);
                    result.db_instance_id = instance.DBInstanceIdentifier;
                    if (instance && instance.Endpoint) {
                        result.credentials = getCredentials(instance, result.plan_id);
                    }

                    callback(null, result);
                },
                function(err, result) {
                    if (err) {
                        response.send(500, {
                            'description': err
                        });
                    } else {
                        response.send(result);
                    }
                });
        } else {
            response.send(500, err);
        }
        next();
    });
});

//---------------------------------------end of /v2/service_instances API-----------------------------------------------

/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id> /service_bindings/<bind id> to bind application to existing
 * service. AWS provisioning will be asynchronous so binding will have to be a subsequent step
 *              1) Service ID (optional) - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB. BODY
 *              2) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller. URL
 *              3) Plan ID (optional) - this uniquely identifies the attributes of the instance,
 *                                      e.g. physical resources, iiops,etc. BODY
 *              4) App_GUID - this is the guid of the application that is being bound to the service. BODY
 *              5) Bind ID - this is an id that is generated by the Cloud Controller, it must be tracked such that an
 *                           unbind correctly deletes credentials associated with a given service. URL
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 *  TODO: Change credential management to vault, flow should be:
 *          1) Ensure instance id exists
 *          2) Check bind id and do the following:
 *              a) If bind id is non-unique, generate new set of credentials, i.e. rebind
 *              b) If bind id is unique, generate new set of credentials, i.e. bind
 *          3) Tag RDS instance with bind id
 *          4) Tag vault credentials with bind id
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.put('/v2/service_instances/:instance_id/service_bindings/:binding_id', function(req, response, next) {
    var reply = {};

    getAllDbInstances(new DbInstanceIdFilter(req.params.instance_id), function(err, allDatabaseInstances) {
        var i = 0,
            instance = null,
            tag = null;

        if (!err) {
            if (allDatabaseInstances && allDatabaseInstances.length > 0) {
                instance = allDatabaseInstances[0];
                if (instance && instance.Endpoint) {
                    //TODO: Credentials on a bind needs to be generated, stored in vault
                    reply.credentials = getCredentials(instance, getPlanId(instance));
                    response.send(reply);
                } else {
                    response.send(503, {
                        'description': "No endpoint set on the instance '" + instance.DBInstanceIdentifier + "'. The instance is in state '" + instance.DBInstanceStatus + "'. please retry a few minutes later"
                    });
                }
            } else {
                response.send(500, {
                    'description': 'database instance has been deleted.'
                });
            }
        } else {
            response.send(500, {
                'description': err
            });
        }
        next();
    });
});

//-----------------------end of /v2/service_instances/:instance_id/service_bindings/:binding_id------------------------- 

/**---------------------------------------------------------------------------------------------------------------------
 * Map broker api /v2/service_instances/<instance id> /service_bindings/<bind id> to unbind application from existing
 * service. AWS de-provisioning will be asynchronous but credential deletion from Vault will be synchronous
 *              1) Service ID (optional) - this uniquely identifies the service in Cloud Foundry, e.g. MariaDB. URL
 *              2) Instance ID - this uniquely identifies the instance of the service, this ID is generated by the
 *                               Cloud Controller. URL
 *              3) Plan ID (optional) - this uniquely identifies the attributes of the instance,
 *                                      e.g. physical resources, iiops,etc. URL
 *              4) Bind ID - this is an id that is generated by the Cloud Controller, it must be tracked such that an
 *                           unbind correctly deletes credentials associated with a given service. URL
 *
 *     See http://docs.cloudfoundry.org/services/api.html for more info
 *
 *  TODO: Change credential management to vault, flow should be:
 *          1) Ensure instance id exists
 *          2) Check bind id and do the following:
 *              a) If bind id is non-unique, generate new set of credentials, i.e. rebind
 *              b) If bind id is unique, generate new set of credentials, i.e. bind
 *          3) Tag RDS instance with bind id
 *          4) Tag vault credentials with bind id
 *
 ---------------------------------------------------------------------------------------------------------------------*/
server.del('/v2/service_instances/:instance_id/service_bindings/:id', function(req, response, next) {
    response.send({});
    next();
});

//-------------------------------end /v2/service_instances/:instance_id/service_bindings/:id----------------------------

//Retrieve AWS Tag Value TODO: Delete?
function getTagValue(instance, key) {
    var i, tag;
    for (i = 0; i < instance.TagList.length; i += 1) {
        tag = instance.TagList[i];
        if (tag.Key === key) {
            return tag.Value;
        }
    }
    return undefined;
}

//Get ServiceID Tag Value TODO: Delete?
function getServiceId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-SERVICE-ID');
}

//Get PlanID Tag Value TODO: Delete?
function getPlanId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-PLAN-ID');
}

//Get OrgID Tag Value TODO: Delete?
function getOrgId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-ORG-ID');
}

//Get SpaceID Tag Value TODO: Delete?
function getSpaceId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-SPACE-ID');
}

//Get Instance ID  TODO: Delete?
function getInstanceId(instance) {
    return getTagValue(instance, 'CF-AWS-RDS-INSTANCE-ID');
}


//generate an instance ID - TODO: Delete, instance ID is generated by caller, e.g. Cloud Foundry
function generateInstanceId(prefix) {
    if (prefix!=null) {
        return prefix.concat('-').concat((Math.floor(Date.now() / 100).toString(16)));
    } else {
        throw new Error("Database name is missing please specify name in your request");
    }
}


//generate an AWS management URL for instance - not to exposed to consumers - keep for testing purposes
function createDashboardUrl(params) {
    var dashboardUrl = Handlebars.compile('https://{{region}}.console.aws.amazon.com/rds/home?region={{region}}#dbinstance:id={{id}}');
    return {
        dashboard_url: dashboardUrl({
            region: aws.config.region,
            id: params.DBInstanceIdentifier
        })
    };
}

/**----------------------------------------------------
 * Retrieve root password for database server instance
 * TODO: Delete
 -----------------------------------------------------*/
var getCredentials = function getCredentials(instance, plan_id) {
    var credentials, hostname, port;

    if (instance.Endpoint) {
        hostname = instance.Endpoint.Address;
        port = instance.Endpoint.Port;
    }

    credentials = {
        'name': instance.DBName,
        'hostname': hostname,
        'host': hostname,
        'port': port,
        'user': instance.MasterUsername,
        'username': instance.MasterUsername,
        'password': getPassword(instance)
    };

    if (instance.Endpoint) {
        credentials.uri = urlTemplates[plan_id](credentials);
        credentials.jdbcUrl = "jdbc:".concat(credentials.uri);
    }

    return credentials;
};


/**-------------------------------------------------------------------------
 *
 * This checks to ensure that broker api version is specified and supported
 * 
 * @param version
 * @returns {Function}
 --------------------------------------------------------------------------*/
function apiVersionChecker(version) {
    var header = 'x-broker-api-version';
    return function(request, response, next) {
        if (request.headers[header]) {
            var pattern = new RegExp('^' + version.major + '\\.\\d+$');
            if (!request.headers[header].match(pattern)) {
                console.log('Incompatible services API version: ' + request.headers[header]);
                response.status(412);
                next(new restify.PreconditionFailedError('Incompatible services API version'));
            }
        } else {
            console.log(header + ' is missing from the request');
        }
        next();
    };
}


/**--------------------------------------------------------------------
 *
 *  Generates the configuration for the RDS instance based on
 *  client request
 *
 *--------------------------------------------------------------------*/
function configureRDSRequest(request){
    //var plan = loadPlan(request.params.plan_id);
    // Generate the new databases admin/root account and place into Vault
    var creds = generateDBRootCredentials(request.params.id);
    var params = {
        Tags: [{
            'Key': 'CF-AWS-RDS-SERVICE-ID',
            'Value': request.params.service_id
        },
            {
                'Key': 'CF-AWS-RDS-PLAN-ID',
                'Value': request.params.plan_id
            },
            {
                'Key': 'CF-AWS-RDS-ORG-ID',
                'Value': request.params.organization_guid
            },
            {
                'Key': 'CF-AWS-RDS-SPACE-ID',
                'Value': request.params.space_guid
            },
            {
                'Key': 'CF-AWS-RDS-INSTANCE-ID',
                'Value': request.params.id
            },
            {
                'Key': 'Costcenter',
                'Value': request.params.cost_center
            }],
        StackName: "inst" + request.params.id + "-org" + request.params.organization_guid + "-space" + request.params.space_guid,
        Capabilities: ['CAPABILITY_IAM'],
        OnFailure: 'DELETE',
        Parameters: [{
            ParameterKey: 'DBName',
            ParameterValue: request.params.db_name
        },
            {
                ParameterKey: 'DBUser',
                ParameterValue: creds.userID
            },
            {
                ParameterKey: 'DBPassword',
                ParameterValue: creds.password
            }],
        //ResourceTypes: ['AWS::RDS'],
        TemplateBody: JSON.stringify(loadPlan(request.params.plan_id)),
        TimeoutInMinutes: 20
    };
  return params;
}

/**--------------------------------------------------------------------
 *
 * TODO: Need to migrate to DB to support multiple brokers
 * TODO:Need cleanup mmechanism for instances that have been deleted
 *--------------------------------------------------------------------*/
function updateStatus(instanceId,org_Id,space_Id,stackId,status) {
    if (status == "remove") {
        delete instances[instanceId];
    }
    //check to see if it exists
    if (instanceId in instances) {
        //update its status
        var attr = instances[instanceId];
        attr.status = status;
        instances[instanceId] = attr;
    } else {
        //else new stack, track its status
        var attributes = {org_Id,space_Id,stackId,status};
        //update status of using instance id and stackname
        instances[instanceId] = attributes;
    }
}

/**-----------------------------------------------------------------
 *
 * Load the appropriate cloud formation based on the plan id
 *
 *------------------------------------------------------------------*/
function loadPlan(planId){
    var plan = "";

    for(var i=0; i < config.catalog.services[0].plans.length;i++){
        if (config.catalog.services[0].plans[i].id==planId){
            plan = require("./config/"+config.plans[planId].formation_name);
            return plan;
        }
    }
}

/**------------------------------------------------------------------
 *
 * Create RDS instance using appropriate cloud formation template
 *
 *------------------------------------------------------------------*/

function createRDSFromFormation(request, response, next, plan, vaultClient) {
    var parameters = configureRDSRequest(request);
    cloudFormation.createStack(parameters, function (err, data) {
        if (err != null) {
            //check to see if there is a stackId present
            if (data != null) {
                updateStatus(request.id, request.params.organization_guid, request.params.space_guid, data.StackId, "failed");
            }
            console.log(err, err.stack); // an error occurred
            if (data.statusCode == "400") {
                response.send(409);
            }
            else {
                response.send(501, data.message);
            }
        }
        else {
            console.log(data);
            //data = {StackName: parameters.StackName};
            //var polling = AsyncPolling(dbInstanceCreationComplete(data),30000).run();

            //create the root account for the db instance in vault, we may have to delete later if the
            //provisioning doesnt complete successfully
            var dbInstanceAdminCredentials = {
                userID: parameters.Parameters[1].ParameterValue,
                password: parameters.Parameters[2].ParameterValue
            };
            createMySQLRootAccount(dbInstanceAdminCredentials, request.params.organization_guid, request.params.id, vaultClient);
            updateStatus(request.params.id, request.params.organization_guid, request.params.space_guid, data.StackId, "in progress");
            response.send(202, "Provisioning request successful");
        }
    });
}
/**
 *
 *  Mount new MySQL Secret Backend
 *
 *   1) Create new MySQL Mounts
 *      for Vault, e.g. mysql-dev-<groupid>-<instanceId>
 *   2) Configure connection to new instance
 *   3) Create read and write roles
 *
 */
function createMYSQLRootAccount(instanceCredentials, groupid, instanceID, vaultClient) {

    if (!vaultClient.isAuthenticated()) {
        authenticateViaAPPID(vaultClient);
    }
    //mount a new mysql secret backend
    var mountPoint = process.env.VAULT_MYSQL_MOUNT_BASE + "-" + groupid + "-" + instanceID;
    var path = process.env.VAULT_API_VERSION + process.env.VAULT_MOUNT_URL + mountPoint;
    var options = {
        type: "mysql",
        description: "MySQL Mount for Group:" + groupid + " Instance:" + instanceID
    };
    vaultClient.configureRestifyClient();
    vaultClient.restifyClient.put(path, options, function (err, req, res, obj) {
        if (err != null) {
            console.log(err, err.stack);
        }
        else {
            //TODO:Determine different response codes
            //configure the connection to the new instance mount point, the url will have to be updated
            //once the RDS instance has been fully provisioned
            path = process.env.VAULT_API_VERSION + mountPoint + process.env.VAULT_MYSQL_CONFIG_BASE;
            options = {connection_url: instanceCredentials.userID + ":" + instanceCredentials.password + "@tcp"};
            vaultClient.restifyClient.put(path, options, function (err, req, res, obj) {
                if (err != null) {
                    console.log(err, err.stack);
                }
                else {
                    //TODO:Determine different response codes
                    console.log('%j', obj);
                    //create write and read roles for the new instance
                }
            });

        }
    });
}
/**function dbInstanceCreationComplete(req){
    cloudFormation.describeStacks(req,function(err,data){
        //some error encounter with provisioning, exit
        if (err!=null) {
            //check to see if there is a stackId present
            if (data != null) {
                updateStatus(request.id, request.params.organization_guid, request.params.space_guid, data.StackId, "failed");
            }
            console.log(err, err.stack); // an error occurred
            if (data.statusCode == "400") {
                response.send(409);
            }
            else{
                response.send(501,data.message);
            }
            this.stop();
        }
        else {
            //check status of the call to see if it is "CREATE_COMPLETE"
            //create a new root account for the new instance
            var status = data.Stacks[0].StackStatus;
            if (status  == "CREATE_COMPLETE"){

            }
            //check to see if it stack creation failed itself
            else{
                switch(status) {
                    case "CREATE_IN_PROGRESS":
                        break;
                    case "CREATE_FAILED":
                        this.stop();
                        break;
                    case "CREATE_COMPLETE":
                        var dbInstanceAdminCredentials = {
                            userID: parameters.parameters['DBUser'],
                            password: parameters.parameters['DBPassword']
                        };
                        createMySQLRootAccount(dbInstanceAdminCredentials, request.params.organization_guid, request.params.id, vaultClient);
                        this.stop();
                        break;
                    case "DELETE_IN_PROGRESS":
                        this.stop();
                        break;
                    case "DELETE_FAILED":
                        this.stop();
                        break;
                    case "DELETE_COMPLETE":
                        this.stop();
                        break;
                    default:
                        this.stop();
                }
            }
        }
    });
}*/

/**-------------------------------------------------------------------------
 * Broker uses basic authentication to ensure the API requestor is known
 * These credentials are generated when pushing broker, are encrypted and
 * stored in Cloud Controller database and passed from Cloud Controller
 * to broker during API invocation
 *
 * @param credentials
 * @returns {Function}
 --------------------------------------------------------------------------*/

function authenticateBrokerCaller(credentials) {
    return function (request, response, next) {
        if (credentials.authUser || credentials.authPassword) {
            if (!(request.authorization && request.authorization.basic && request.authorization.basic.username === credentials.authUser && request.authorization.basic.password === credentials.authPassword)) {
                response.status(401);
                response.setHeader('WWW-Authenticate', 'Basic "realm"="' + server.name + '"');
                next(new restify.InvalidCredentialsError("invalid username or password"));
            } else {
                // authenticated!
            }
        } else {
            // no authentication required.
        }
        next();
    };
}
/**--------------------------------------------------------------------
 *
 * The following are required to provision new instances of RDS:
 *
 * 1) Plan ID
 * 2) Organization ID
 * 3) Space ID
 * 4) Database Name
 * 5) A flag indicating it accepts incomplete requests because of the
 *    longer provisioning period for RDS
 * 6) Cost Center
 * 7) Instance ID (generated by Cloud Controller in PCF environment)
 *
 ----------------------------------------------------------------------*/

function validateProvisioningRequest(request){
    var msg="";
    if(!request.params.hasOwnProperty("accepts_incomplete")|| !request.params.accepts_incomplete ){
        msg="-Client must support asynchronous provisioning";
    }
    if(!request.params.hasOwnProperty("plan_id") || !(request.params.plan_id in config.plans)){
        msg=msg+"-No plan id provided or plan id is invalid";
    }
    if(!request.params.hasOwnProperty("organization_guid")){
        msg=msg+"-No organization provided";
    }
    if(!request.params.hasOwnProperty("space_guid")){
        msg=msg+"-No space provided";
    }
    if(!request.params.hasOwnProperty("db_name")){
        msg=msg+"-No database server name provided";
    }
    if(!request.params.hasOwnProperty("cost_center")){
        msg=msg+"-No cost center provided";
    }
    if(!request.params.hasOwnProperty("id")){
        msg=msg+"-No instance id provided";
    }
    return msg;
}

server.get(/\/?.*/, restify.serveStatic({
    directory: './public',
    default: 'index.html'
}));

/** According to the spec, the JSON return message should include a description field. */
server.on('uncaughtException', function(req, res, route, err) {
    console.log(err, err.stack);
    res.send(500, {
        'code': 500,
        'description': err.message
    });
});

//checkConsistency();
urlTemplates = compileTemplates();

var port = Number(process.env.VCAP_APP_PORT || 5001);
server.listen(port, function() {
    console.log('%s listening at %s', server.name, server.url)
});

function authenticateViaAPPID(vaultClient) {
    var vaultPath = process.env.VAULT_API_VERSION + process.env.VAULT_APPID_PATH + process.env.VAULT_APPID;
    var payload = {user_id: process.env.VAULT_USERID};
    vaultClient.restifyClient.post(vaultPath, payload, function (err, req, res, obj) {
        if (err != null) {
            console.log(err, err.stack);
        }
        else {
            //save the vault client token that can be used for all subsequent requests
            vaultClient.clientToken = obj.auth.client_token;
            console.log() = obj.auth.client_token;
        }
    });
}
/**
 *  TODO: Need to arrive at a password generation mechanism
 *  This will be used by both original provisioning for generating root account as well as for bind/re-bind.
 *  The resulting credential will be stored in vault
 *
 */
function generateDBRootCredentials(instanceID) {
    var creds = {
        userID: "",
        password: ""
    };
    creds.userID = "brokered" + instanceID;
    creds.password = generatePassword(24, false, /[\d]/);
    return creds;
}


